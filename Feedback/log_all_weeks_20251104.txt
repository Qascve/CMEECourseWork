======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Zhou Yang

Processing all weeks found in repository

Your current Git repo size is about 2.95 MiB on disk

Found directories: .git, week1, week4, week2, Feedback, week3
Found files: .gitignore, README.md

Processing all weeks: week1, week4, week2, week3

Found 63 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: csvtospace.sh

Contents:

**********
#!/bin/bash
# Author:zy3425@ic.ac.uk
# Script: csvtospace.sh
# Description:
# Converts a CSV file to a space-separated file


echo "Please enter  file names: "

read file

if [[ $file != *.csv ]]; then
    echo "Error: Input file is not a .csv file"
    exit 1
fi

# Define outputpath
outputPath="../results/$(basename "$file" .csv)_space_separated_version.txt"
echo "Creating space-separated version of $file as $outputPath ..."

# Convert commas to spaces
tr ',' ' ' <"$file" >"$outputPath"
echo "Done,Output saved to path:$outputPath"

**********

Output (first 500 chars):

**********
Please enter  file names: 
Error: Input file is not a .csv file

**********
No errors.
======================================================================
Script: concatenateTwoFiles.sh

Contents:

**********
#!/bin/bash

echo "Usage: bash concatenateTwoFiles.sh File1 File2 Outputfile"

echo -n "Please enter three file names (file1 file2 outputfile): "

read file1 file2 outputfile

if [ $# -eq 0 ]; then # Check if any arguments are provided
    echo "Error: No input provided"
    exit 1
fi

if [ ! -f "$file1" ] || [ ! -f "$file2" ]; then
    echo "Error: Input file does not exist"
    exit 1
fi
echo "Merging $file1 and $file2 into $outputfile ..."

cat $file1 > $outputfile
cat $file2 >> $outputfile
echo "Merged File is"
cat $outputfile
**********

Output (first 500 chars):

**********
Usage: bash concatenateTwoFiles.sh File1 File2 Outputfile
Please enter three file names (file1 file2 outputfile): Error: No input provided

**********
No errors.
======================================================================
Script: myExampleScript.sh

Contents:

**********
#!/bin/sh

MSG1="Hello"
MSG2=$USER
echo "$MSG1 $MSG2"
echo "Hello $USER"
echo
**********

Output (first 500 chars):

**********
Hello mhasoba
Hello mhasoba


**********
No errors.
======================================================================
Script: tiff2png.sh

Contents:

**********
#!/bin/bash

if [ $# -eq 0 ]; then # Check if any arguments are provided
    echo "Error: No input provided"
    exit 1
fi

for f in *.tif; 
    do  
        echo "Converting $f"; 
        convert "$f"  "$(basename "$f" .tif).png"; 
    done
**********

Output (first 500 chars):

**********
Error: No input provided

**********
No errors.
======================================================================
Script: boilerplate.sh

Contents:

**********
#!/bin/sh
# Author: zy3425@imperial.ac.uk
# Script: boilerplate.sh
# Desc: simple boilerplate for shell scripts
# Arguments: none
# Date: Sep 2025

echo -e "\nThis is a shell script! \n"
exit # successful completion
**********

Output (first 500 chars):

**********

This is a shell script! 


**********
No errors.
======================================================================
Script: tabtocsv.sh

Contents:

**********
#!/bin/sh
# Author: zy3425@imperial.ac.uk
# Script: tabtocsv.sh
# Description: substitute the tabs in the files with commas
#
# Saves the output into a .csv file
# Arguments: 1 -> tab delimited file
# Date: Sep 2025


if [ $# -eq 0 ]; then # Check if any arguments are provided
    echo "Error: No input provided"
    exit 1
fi

echo "Creating a comma delimited version of $1 ..."
cat $1 | tr -s "\t" "," >> $1.csv
echo -e "test \t\t test" >> ../sandbox/test.txt # relative path
echo "Done!"
exit

**********

Output (first 500 chars):

**********
Error: No input provided

**********
No errors.
======================================================================
Script: countLines.sh

Contents:

**********
#!/bin/bash


if [ $# -eq 0 ]; then # Check if any arguments are provided
    echo "Error: No input provided"
    exit 1
fi

NumLines=`wc -l < $1`
echo "The file $1 has $NumLines lines"
echols
**********

Output (first 500 chars):

**********
Error: No input provided

**********
No errors.
======================================================================
Script: variables.sh

Contents:

**********
#!/bin/sh

## Illustrates the use of variables 

# Special variables

echo "This script was called with $# parameters"
echo "The script's name is $0"
echo "The arguments are $@"
echo "The first argument is $1"
echo "The second argument is $2"

# Assigned Variables; Explicit declaration:
MY_VAR='learning shell scripting is not fun!' 
echo 'the current value of the variable is:' $MY_VAR
echo #space line
echo 'Please enter a new string'
read MY_VAR
echo

if [ $# -eq 0 ]; then # Check if any arguments are provided
    echo "Error: No input provided"
    exit 1
fi

echo 'the current value of the variable is:' $MY_VAR
echo #space line

## Assigned Variables; Reading (multiple values) from user input:
echo 'Enter two numbers separated by space(s)'
read a b

if [ $# -eq 0 ]; then # Check if any arguments are provided
    echo "Error: No input provided"
    exit 1
fi

echo #space line
echo 'you entered' $a 'and' $b '; Their sum is:'

## Assigned Variables; Command substitution
MY_SUM=$(expr $a + $b)
echo $MY_SUM
**********

Output (first 500 chars):

**********
This script was called with 0 parameters
The script's name is variables.sh
The arguments are 
The first argument is 
The second argument is 
the current value of the variable is: learning shell scripting is not fun!

Please enter a new string

Error: No input provided

**********
No errors.
======================================================================
Script: compileLaTeX.sh

Contents:

**********
#!/bin/bash
# Compile LaTeX document

if [ $# -eq 0 ]; then # Check if any arguments are provided
    echo "Error: No input provided"
    exit 1
fi

if [[ $file != *.tex ]]; then
    echo "Error: Input file is not a .tex file"
    exit 1
fi


if [[ $1 == *.tex ]]; then
    filename=${1%.tex} # Remove file extension
else
    filename=$1 # Use the provided name
fi

pdflatex $filename.tex
bibtex $filename
pdflatex $filename.tex
pdflatex $filename.tex
evince $filename.pdf &

## Cleanup
rm *.aux
rm *.log
rm *.bbl
rm *.blg
**********

Output (first 500 chars):

**********
Error: No input provided

**********
No errors.
======================================================================
Script: PP_Dists.R

Contents:

**********
library(tidyverse)
library(here)


# Load data
data <- read.csv(here("week4", "data", "EcolArchives-E089-51-D1.csv"))


# Create log-transformed columns
data <- data %>%
  mutate(
    logPredMass = log10(Predator.mass),
    logPreyMass = log10(Prey.mass),
    logSizeRatio = log10(Prey.mass / Predator.mass)
  )

# Get all feeding types
feeding_types <- unique(data$Type.of.feeding.interaction)


# Plot: Predator mass distributions
pdf(here("week4", "results", "Pred_Subplots.pdf"),width=10, height=12)
par(mfrow = c(3, 2))  # adjust layout based on number of feeding types
for (ftype in feeding_types) {
  subset_data <- subset(data, Type.of.feeding.interaction == ftype)
  hist(
    subset_data$logPredMass,
    main = paste("Predator mass:", ftype),
    xlab = "log10(Predator mass)",
    col = "lightblue",
    border = "white"
  )
}
dev.off()


# Plot: Prey mass distributions
pdf(here("week4", "results", "Prey_Subplots.pdf"),width=10, height=12)
par(mfrow = c(3, 2))
for (ftype in feeding_types) {
  subset_data <- subset(data, Type.of.feeding.interaction == ftype)
  hist(
    subset_data$logPreyMass,
    main = paste("Prey mass:", ftype),
    xlab = "log10(Prey mass)",
    col = "lightgreen",
    border = "white"
  )
}
dev.off()


# Plot: Size ratio distributions

pdf(here("week4", "results", "SizeRatio_Subplots.pdf"),width=10, height=12)
par(mfrow = c(3, 2))
for (ftype in feeding_types) {
  subset_data <- subset(data, Type.of.feeding.interaction == ftype)
  hist(
    subset_data$logSizeRatio,
    main = paste("Size ratio:", ftype),
    xlab = "log10(Prey/Predator mass)",
    col = "lightcoral",
    border = "white"
  )
}
dev.off()


# Compute mean and median log values by feeding type

results <- data %>%
  group_by(Type.of.feeding.interaction) %>%
  summarise(
    MeanPredMass = mean(logPredMass, na.rm = TRUE),
    MedianPredMass = median(logPredMass, na.rm = TRUE),
    MeanPreyMass = mean(logPreyMass, na.rm = TRUE),
    MedianPreyMass = median(logPreyMass, na.rm = TRUE),
    MeanSizeRatio = mean(logSizeRatio, na.rm = TRUE),
    MedianSizeRatio = median(logSizeRatio, na.rm = TRUE)
  )


# Save results to CSV
write.csv(results, here("week4", "results", "PP_Results.csv"), row.names = FALSE)

print("Analysis complete")
**********

Output (first 500 chars):

**********

**********
Errors:
**********
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.4.4     ✔ tibble    3.3.0
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.0.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
here() starts at /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425
Error in pdf(here("week4", "results", "Pred_Subplots.pdf"), width = 10,  : 
  cannot open file '/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425/week4/results/Pred_Subplots.pdf'
Execution halted

**********
======================================================================
Script: profileme2.py

Contents:

**********
def my_squares(iters):
    out = [i ** 2 for i in range(iters)]
    return out

def my_join(iters, string):
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")
**********

Output (first 500 chars):

**********
10000000 My string

**********
No errors.
======================================================================
Script: PP_Regress.R

Contents:

**********
# Load required libraries
library(ggplot2)
library(dplyr)
library(here)

MyDF <- read.csv(here("week4", "data", "EcolArchives-E089-51-D1.csv"), stringsAsFactors = FALSE)

# Data cleaning: remove rows with missing values in key columns
MyDF <- MyDF[complete.cases(MyDF[, c("Predator.mass", "Prey.mass", "Type.of.feeding.interaction", "Predator.lifestage")]), ]

# Some records have mg units, need to convert to g (divide by 1000)
mg_indices <- which(MyDF$Prey.mass.unit == "mg")
MyDF$Prey.mass[mg_indices] <- MyDF$Prey.mass[mg_indices] / 1000

# Filter out invalid mass values (zero or negative)
MyDF <- MyDF[MyDF$Predator.mass > 0 & MyDF$Prey.mass > 0, ]

# Faceted by feeding type, colored by predator life stage
p <- ggplot(MyDF, aes(x = Prey.mass, y = Predator.mass, color = Predator.lifestage)) +
  # Add semi-transparent points
  geom_point(alpha = 0.6, size = 1.5, shape = 3) +
  # Create separate panels for each feeding interaction type
  facet_grid(Type.of.feeding.interaction ~ ., scales = "fixed") +
  # Add regression lines with confidence intervals for each life stage
  geom_smooth(method = "lm", se = TRUE, linewidth = 0.8, fullrange = TRUE) +
  scale_x_log10(name = "Prey Mass in grams") +
  scale_y_log10(name = "Predator mass in grams", labels = scales::scientific) +
  # Use black and white theme
  theme_bw() +
  theme(
    strip.text.y = element_text(angle = -90, hjust = 0, size = 10),
    strip.background = element_rect(fill = "lightgray"),
    legend.position = "bottom",
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.text = element_text(size = 8),
    axis.title = element_text(size = 10)
  ) +
  # Set legend title
  labs(color = "Predator.lifestage")

# Save the plot to PDF in the results directory
pdf(here("week4", "results", "PP_Regress.pdf"), width = 10, height = 12)
suppressWarnings(print(p))
invisible(dev.off())

results <- data.frame(
  Feeding.Type = character(),
  Predator.Lifestage = character(),
  Slope = numeric(),
  Intercept = numeric(),
  R.squared = numeric(),
  F.statistic = numeric(),
  P.value = numeric(),
  stringsAsFactors = FALSE
)

# Get all unique combinations of feeding types and life stages
feeding_types <- unique(MyDF$Type.of.feeding.interaction)
life_stages <- unique(MyDF$Predator.lifestage)

# Loop through all feeding type × life stage combinations
for (feeding in feeding_types) {
  for (stage in life_stages) {
    # Subset data for current combination
    subset_data <- MyDF[MyDF$Type.of.feeding.interaction == feeding & MyDF$Predator.lifestage == stage, ]

    # Only perform regression if there are at least 3 data points
    if (nrow(subset_data) >= 3) {
      # Fit linear model to log-transformed data
      # This fits: log(Predator.mass) ~ log(Prey.mass)
      model <- lm(log(Predator.mass) ~ log(Prey.mass), data = subset_data)
      
      # Get model summary# Initialize an empty dataframe to store regression results
      model_summary <- summary(model)
      
      # Extract regression coefficients
      intercept <- coef(model)[1]
      slope <- coef(model)[2]
      
      # Extract R-squared value
      r_squared <- model_summary$r.squared
      
      # Extract F-statistic
      f_statistic <- model_summary$fstatistic[1]
      
      # Calculate p-value from F-statistic
      p_value <- pf(model_summary$fstatistic[1], model_summary$fstatistic[2], model_summary$fstatistic[3], lower.tail = FALSE)
      
      # Append results to the dataframe
      results <- rbind(results, data.frame(
        Feeding.Type = feeding,
        Predator.Lifestage = stage,
        Slope = slope,
        Intercept = intercept,
        R.squared = r_squared,
        F.statistic = f_statistic,
        P.value = p_value,
        stringsAsFactors = FALSE
      ))
    }
  }
}

# Sort results by feeding type and life stage for better readability
results <- results[order(results$Feeding.Type, results$Predator.Lifestage), ]

# Save results to CSV file in the results directory
write.csv(results, here("week4", "results", "PP_Regress_Results.csv"), row.names = FALSE)
**********

Output (first 500 chars):

**********

**********
Errors:
**********

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

here() starts at /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425
Error in pdf(here("week4", "results", "PP_Regress.pdf"), width = 10, height = 12) : 
  cannot open file '/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425/week4/results/PP_Regress.pdf'
Execution halted

**********
======================================================================
Script: profileme.py

Contents:

**********
def my_squares(iters):
    out = []
    for i in range(iters):
        out.append(i ** 2)
    return out

def my_join(iters, string):
    out = ''
    for i in range(iters):
        out += string.join(", ")
    return out

def run_my_funcs(x,y):
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")
**********

Output (first 500 chars):

**********
10000000 My string

**********
No errors.
======================================================================
Script: GPDD_Data.R

Contents:

**********

library(maps)
library(here)

# Load the GPDD data
load(here("week4", "data", "GPDDFiltered.RData"))

# Create a world map
map("world", col = "lightgray", fill = TRUE, border = "darkgray", 
    bg = "lightblue", ylim = c(-60, 90))

# Superimpose data points showing GPDD locations
points(gpdd$long, gpdd$lat, col = "red", pch = 20, cex = 0.7)

# Add title
title(main = "Global Population Dynamics Database - Data Locations")

# Analysis based on distribution:
# Most of the data points are concentrated in the Northern Hemisphere, 
# and almost all are from developed countries such as Western Europe and North America, 
# with very few from other regions.

**********

Output (first 500 chars):

**********

**********
Errors:
**********
here() starts at /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425

**********
======================================================================
Script: SQLinR.R

Contents:

**********
#install the sqlite package
install.packages('sqldf')

# To load the packages
library(sqldf)

# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')

# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
            "CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)")

# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data

 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")


# Once we have our table, we can query the results using:

dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")


# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.

Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R

# Import data frames into database
 dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)

# Check that the data have been correctly imported into the School table.
 dbListTables(db)                 # The tables in the database
 dbListFields(db,"Resource")       # The columns in a table
 dbReadTable(db, "Resource")    # The data in a table

# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
 dbDisconnect(db)            # Close connection
 rm(list = c("Resource"))   # Remove data frames



**********

Output (first 500 chars):

**********

**********
Errors:
**********
Installing package into ‘/home/mhasoba/R/x86_64-pc-linux-gnu-library/4.3’
(as ‘lib’ is unspecified)
Error in contrib.url(repos, type) : 
  trying to use CRAN without setting a mirror
Calls: install.packages -> startsWith -> contrib.url
Execution halted

**********
======================================================================
Script: Girko.R

Contents:

**********
library(ggplot2)
library(here)

# Build a function that returns an ellipse (predicted eigenvalue boundary)
build_ellipse <- function(hradius, vradius){
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)
  return(data.frame(x = x, y = y))
}

# Set matrix
N <- 250
M <- matrix(rnorm(N * N), N, N)

eigvals <- eigen(M)$values
MyBars.R
# Build dataframe
eigDF <- data.frame(
  "Real" = Re(eigvals),
  "Imaginary" = Im(eigvals)
)

# Compute theoretical radius
radius <- sqrt(N)

# Build dataframe for the ellipse boundary
ellDF <- build_ellipse(radius, radius)
names(ellDF) <- c("Real", "Imaginary")

# Create plot
p <- ggplot(eigDF, aes(x = Real, y = Imaginary)) +
  geom_point(shape = I(MyBars.R3)) +
  geom_hline(aes(yintercept = 0)) +
  geom_vline(aes(xintercept = 0)) +
  geom_polygon(
    data = ellDF,
    aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red")
  ) +
  theme(legend.position = "none") +
  ggtitle("Girko Circular Law")

# Save plot to PDF
pdf(here("week4", "results", "Girko.pdf"), width = 8, height = 8)
print(p)
dev.off()

print("Complete")
**********

Output (first 500 chars):

**********

**********
Errors:
**********
here() starts at /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425
Error: object 'MyBars.R' not found
Execution halted

**********
======================================================================
Script: DataWrangTidy.R

Contents:

**********
################################################################
################## Wrangling the Pound Hill Dataset (tidyverse) #
################################################################

library(tidyverse)  # includes dplyr, tidyr, readr, ggplot2, etc.
library(here)       # for constructing file paths

############# Load the dataset ###############
# header = FALSE because the raw data don't have real headers
MyData <- read_csv(here("week4", "data", "PoundHillData.csv"), col_names = FALSE)

# header = TRUE because metadata has real headers
MyMetaData <- read_csv2(here("week4", "data", "PoundHillMetaData.csv"))

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
glimpse(MyData)

############# Transpose ###############
# convert tibble to matrix for transposing
MyData <- t(as.matrix(MyData))
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] <- 0

############# Convert raw matrix to data frame ###############
TempData <- as_tibble(MyData[-1, ], .name_repair = "minimal")
colnames(TempData) <- MyData[1, ]

############# Convert from wide to long format ###############
data <- TempData %>%
  pivot_longer(
    cols = -c(Cultivation, Block, Plot, Quadrat),
    names_to = "Species",
    values_to = "Count"
  )

############# Change data types ###############
data <- data %>%
  mutate(
    Cultivation = as.factor(Cultivation),
    Block = as.factor(Block),
    Plot = as.factor(Plot),
    Quadrat = as.factor(Quadrat),
    Count = as.integer(Count)
  )

############# Inspect final dataset ###############
glimpse(data)
head(data)
dim(data)

**********

Output (first 500 chars):

**********
# A tibble: 6 × 60
  X1     X2    X3    X4    X5    X6    X7    X8    X9    X10   X11   X12   X13  
  <chr>  <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>
1 Culti… octo… octo… octo… octo… octo… may   may   may   may   may   march march
2 Block  a     a     a     a     a     a     a     a     a     a     a     a    
3 Plot   1     1     1     1     1     2     2     2     2     2     3     3    
4 Quadr… Q1    Q2    Q3    Q4    Q5    Q1    Q2    Q3    Q4    Q5    Q1    Q
**********
Errors:
**********
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.4.4     ✔ tibble    3.3.0
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.0.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
here() starts at /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425
Rows: 45 Columns: 60
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (60): X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15, ...

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
ℹ Using "','" as decimal and "'.'" as grouping mark. Use `read_delim()` for more control.
Rows: 5 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ";"
chr (2): FieldName, Description

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

**********
======================================================================
Script: DataWrang.R

Contents:

**********
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
library(here)
MyData <- as.matrix(read.csv(here("week4", "data", "PoundHillData.csv"), header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv(here("week4", "data", "PoundHillMetaData.csv"), header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

**********

Output (first 500 chars):

**********
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""  
**********
Errors:
**********
here() starts at /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425
Vim: Warning: Output is not to a terminal
Vim: Warning: Input is not from a terminal


**********
======================================================================
Script: MyBars.R

Contents:

**********
library(ggplot2)
library(here)

file_path <- here("week4", "data", "Results.txt")
if (!file.exists(file_path)) {
  warning("Warning: '../data/Results.txt' not found. Skipping plot creation.")
  quit(status = 0)
}


a <- read.table(file_path, header = TRUE)


# Add ymin column
a$ymin <- rep(0, nrow(a))

# Base plot
p <- ggplot(a)

# First linerange
p <- p + geom_linerange(data = a, aes(x = x, ymin = ymin, ymax = y1),
                        colour = "#E69F00", linewidth = 0.5, alpha = 0.5, show.legend = FALSE)

# Second linerange
p <- p + geom_linerange(data = a, aes(x = x, ymin = ymin, ymax = y2),
                        colour = "#56B4E9", linewidth = 0.5, alpha = 0.5, show.legend = FALSE)

# Third linerange
p <- p + geom_linerange(data = a, aes(x = x, ymin = ymin, ymax = y3),
                        colour = "#D55E00", linewidth = 0.5, alpha = 0.5, show.legend = FALSE)

# Add text labels
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# Axis labels and theme
p <- p + scale_x_continuous("My x axis", breaks = seq(3, 5, by = 0.05)) +
         scale_y_continuous("My y axis") +
         theme_bw() +
         theme(legend.position = "none")

# Save to PDF
pdf("../results/MyBars.pdf")
print(p)
dev.off()

**********

Output (first 500 chars):

**********

**********
Errors:
**********
here() starts at /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425
Warning message:
Warning: '../data/Results.txt' not found. Skipping plot creation. 

**********
======================================================================
Script: LV1.py

Contents:

**********
import numpy as np
import scipy as sc
import matplotlib.pylab as plt

def dCR_dt(pops, t=0):

    R = pops[0]
    C = pops[1]
    dRdt = r * R - a * R * C 
    dCdt = -z * C + e * a * R * C
    
    return np.array([dRdt, dCdt])

r = 1.
a = 0.1 
z = 1.5
e = 0.75
t = np.linspace(0, 15, 1000)

R0 = 10
C0 = 5 
RC0 = np.array([R0, C0])
pops, infodict = sc.integrate.odeint(dCR_dt, RC0, t, full_output=True)

type(infodict)
infodict.keys()
infodict['message']

f1 = plt.figure()

plt.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
plt.plot(t, pops[:,1]  , 'b-', label='Consumer density')
plt.grid()
plt.legend(loc='best')
plt.xlabel('Time')
plt.ylabel('Population density')
plt.title('Consumer-Resource population dynamics')
# plt.show()# To display the figure

f1.savefig('../results/LV_model.pdf') #Save figure


f2 = plt.figure()
plt.plot(pops[:,0],pops[:,1]  , 'r-') # Plot
plt.grid()
plt.xlabel('Resource density')
plt.ylabel('Consumer density')
plt.title('Consumer-Resource population dynamics')
plt.show()# To display the figure

f2.savefig('../results/LV_model2.pdf') #Save figure
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425/week4/code/LV1.py", line 40, in <module>
    f1.savefig('../results/LV_model.pdf') #Save figure
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3/dist-packages/matplotlib/figure.py", line 3285, in savefig
    self.canvas.print_figure(fname, **kwargs)
  File "/usr/lib/python3/dist-packages/matplotlib/backend_bases.py", line 2338, in print_figure
    result = print_method(
             ^^^^^^^^^^^^^
  File "/usr/lib/python3/dist-packages/matplotlib/backend_bases.py", line 2204, in <lambda>
    print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(
                                                                 ^^^^^
  File "/usr/lib/python3/dist-packages/matplotlib/backends/backend_pdf.py", line 2808, in print_pdf
    file = PdfFile(filename, metadata=metadata)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3/dist-packages/matplotlib/backends/backend_pdf.py", line 713, in __init__
    fh, opened = cbook.to_filehandle(filename, "wb", return_opened=True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3/dist-packages/matplotlib/cbook/__init__.py", line 492, in to_filehandle
    fh = open(fname, flag, encoding=encoding)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../results/LV_model.pdf'

**********
======================================================================
Script: LV2.py

Contents:

**********
import numpy as np
import scipy as sc
import matplotlib.pylab as plt
import sys

# Define the Lotka-Volterra model with resource density dependence
def dCR_dt(pops, t=0):
    R = pops[0]
    C = pops[1]
    # Calculate rate of change for resource and consumer
    dRdt = r * R * (1 - R/K) - a * R * C  # Resource density dependence added
    dCdt = -z * C + e * a * R * C
    
    return np.array([dRdt, dCdt])

# Get command line arguments
if len(sys.argv) != 6:
    print("Error: Need 5 arguments: r, a, z, e, K")
    sys.exit(1)

# Assign command line arguments to parameters
r = float(sys.argv[1])  # Resource growth rate
a = float(sys.argv[2])  # Consumer search rate
z = float(sys.argv[3])  # Consumer mortality rate
e = float(sys.argv[4])  # Consumer efficiency
K = float(sys.argv[5])  # Resource carrying capacity

# Create time array
t = np.linspace(0, 15, 1000)

# Set initial conditions
R0 = 10
C0 = 5 
RC0 = np.array([R0, C0])

# Run the model using scipy's integrator
pops, infodict = sc.integrate.odeint(dCR_dt, RC0, t, full_output=True)

# Plot the results
f1 = plt.figure()
plt.plot(t, pops[:,0], 'g-', label='Resource density')
plt.plot(t, pops[:,1], 'b-', label='Consumer density')
plt.grid()
plt.legend(loc='best')
plt.xlabel('Time')
plt.ylabel('Population density')
plt.title('Consumer-Resource population dynamics\n' + \
         f'r={r:.1f} a={a:.1f} z={z:.1f} e={e:.1f} K={K:.1f}')
f1.savefig('../results/LV2_model.pdf')

# Create the phase plot
f2 = plt.figure()
plt.plot(pops[:,0], pops[:,1], 'r-')
plt.grid()
plt.xlabel('Resource density')
plt.ylabel('Consumer density')
plt.title('Consumer-Resource phase plot\n' + \
         f'r={r:.1f} a={a:.1f} z={z:.1f} e={e:.1f} K={K:.1f}')
f2.savefig('../results/LV2_phase.pdf')

# Print final populations
print(f"Final Resource population: {pops[-1,0]:.3f}")
print(f"Final Consumer population: {pops[-1,1]:.3f}")

plt.show()
**********

Output (first 500 chars):

**********
Error: Need 5 arguments: r, a, z, e, K

**********
No errors.
======================================================================
Script: MyExampleScript.py

Contents:

**********
def foo(x):
    x *= x # same as x = x*x
    print(x)

foo(2)
**********

Output (first 500 chars):

**********
4

**********
No errors.
======================================================================
Script: lc2.py

Contents:

**********
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.
 
heavy_rain = [item for item in rainfall if item[1] > 100]
print (">100mm" , str(heavy_rain))

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

light_rain = [item[0] for item in rainfall if item[1] < 50]
print ( "less than 50 mm", str(light_rain))

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

heavy_rain = [] # create list for month,rainfall tuples where the amount of rain was greater than 100 mm
for item in rainfall:
    if item[1] > 100: # item[1] is the rainfall value
        heavy_rain.append(item) # append the whole tuple
print (">100mm" , str(heavy_rain))

light_rain = [] # create list for month names where the amount of rain was less than 50 mm
for item in rainfall:
    if item[1] < 50:
        light_rain.append(item[0]) # item[0] is the month name, append just the month name
print ( "less than 50 mm", str(light_rain))

# A good example output is:
#
# Step #1:
# Months and rainfall values when the amount of rain was greater than 100mm:
# [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
# ... etc.


**********

Output (first 500 chars):

**********
>100mm [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
less than 50 mm ['MAR', 'SEP']
>100mm [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
less than 50 mm ['MAR', 'SEP']

**********
No errors.
======================================================================
Script: oaks.py

Contents:

**********
## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

## Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

## Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

## Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

## Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)

**********

Output (first 500 chars):

**********
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'QUERCUS CERRIS', 'QUERCUS ROBUR', 'QUERCUS PETRAEA'}
{'QUERCUS CERRIS', 'QUERCUS ROBUR', 'QUERCUS PETRAEA'}

**********
No errors.
======================================================================
Script: dictionary.py

Contents:

**********
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a python script to populate a dictionary called taxa_dic derived from
# taxa so that it maps order names to sets of taxa and prints it to screen.
# 
# An example output is:
#  
# 'Chiroptera' : set(['Myotis lucifugus']) ... etc. 
# OR, 
# 'Chiroptera': {'Myotis  lucifugus'} ... etc

#### Your solution here #### 
taxa_dic = {}
for item in taxa:
    species = item[0]
    order = item[1]
    if order not in taxa_dic:
        taxa_dic[order] = set()  # Initialize a new set for this order
    taxa_dic[order].add(species)  # Add the species to the set for this order

print(taxa_dic)

# Now write a list comprehension that does the same (including the printing after the dictionary has been created)  
 
#### Your solution here #### 

comprehension_taxa_dic = {}
{comprehension_taxa_dic.setdefault(item[1], set()).add(item[0]) for item in taxa} # Set item[1] as key, add item[0] to the set at that key

print(comprehension_taxa_dic)
**********

Output (first 500 chars):

**********
{'Chiroptera': {'Myotis lucifugus'}, 'Rodentia': {'Mus domesticus', 'Gerbillus henleyi', 'Cleithrionomys rutilus', 'Peromyscus crinitus'}, 'Afrosoricida': {'Microgale talazaci', 'Microgale dobsoni'}, 'Carnivora': {'Arctocephalus gazella', 'Canis lupus', 'Lyacon pictus'}}
{'Chiroptera': {'Myotis lucifugus'}, 'Rodentia': {'Mus domesticus', 'Gerbillus henleyi', 'Cleithrionomys rutilus', 'Peromyscus crinitus'}, 'Afrosoricida': {'Microgale talazaci', 'Microgale dobsoni'}, 'Carnivora': {'Arctocephalus
**********
No errors.
======================================================================
Script: cfexercises2.py

Contents:

**********

########################
def hello_1(x):
    for j in range(x):
        if j % 3 == 0:
            print('hello')
    print(' ')

hello_1(12)

########################
def hello_2(x):
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')
    print(' ')

hello_2(12)

########################
def hello_3(x, y):
    for i in range(x, y):
        print('hello')
    print(' ')

hello_3(3, 17)

########################
def hello_4(x):
    while x != 15:
        print('hello')
        x = x + 3
    print(' ')

hello_4(0)

########################
def hello_5(x):
    while x < 100:
        if x == 31:
            for k in range(7):
                print('hello')
        elif x == 18:
            print('hello')
        x = x + 1
    print(' ')

hello_5(12)

# WHILE loop with BREAK
def hello_6(x, y):
    while x: # while x is True
        print("hello! " + str(y))
        y += 1 # increment y by 1 
        if y == 6:
            break
    print(' ')

hello_6 (True, 0)

**********

Output (first 500 chars):

**********
hello
hello
hello
hello
 
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
 
hello! 0
hello! 1
hello! 2
hello! 3
hello! 4
hello! 5
 

**********
No errors.
======================================================================
Script: using_name.py

Contents:

**********
# !/usr/bin/env python3
# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself!')
else:
    print('I am being imported from another script/program/module!')

print("This module's name is: " + __name__)

**********

Output (first 500 chars):

**********
This program is being run by itself!
This module's name is: __main__

**********
No errors.
======================================================================
Script: basic_io3.py

Contents:

**********
import os
import sys
import pickle
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

if not os.path.exists('../sandbox'): ## make sure the folder exists
    print("not found: ../sandbox")
    sys.exit(1)

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
if not os.path.exists('../sandbox/testp.p'):
    print("not found: ../sandbox/testp.p")
    sys.exit(1)
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)
**********

Output (first 500 chars):

**********
not found: ../sandbox

**********
No errors.
======================================================================
Script: scope.py

Contents:

**********
# scope.py

# Local variables and function scope

i = 1
x = 0
for i in range(10):
    x += 1
print(i)  # 9
print(x)  # 10

i = 1
x = 0
def a_function(y):
    x = 0
    for i in range(y):
        x += 1
    return x

a_function(10)
print(i)  # still 1
print(x)  # still 0

# explicitly reassign the result to x
x = a_function(10)
print("Updated x after reassignment:", x)

# Global variables

_a_global = 10  # a global variable

if _a_global >= 5:
    _b_global = _a_global + 5  # also global

print("Before calling a_function, outside the function, _a_global =", _a_global)
print("Before calling a_function, outside the function, _b_global =", _b_global)

def a_function():
    _a_global = 4  # local variable
    if _a_global >= 4:
        _b_global = _a_global + 5  # local variable
    _a_local = 3
    print("Inside function, _a_global =", _a_global)
    print("Inside function, _b_global =", _b_global)
    print("Inside function, _a_local =", _a_local)

a_function()

print("After calling a_function, outside, _a_global (still) =", _a_global)
print("After calling a_function, outside, _b_global (still) =", _b_global)
try:
    print("After calling a_function, outside, _a_local =", _a_local)
except NameError as e:
    print("NameError:", e)


_a_global = 10
def a_function():
    _a_local = 4
    print("Inside function, _a_local =", _a_local)
    print("Inside function, _a_global =", _a_global)

a_function()
print("Outside function, _a_global =", _a_global)

# Modifying a global variable by 'global' keyword
_a_global = 10
print("Before calling a_function, outside, _a_global =", _a_global)

def a_function():
    global _a_global
    _a_global = 5
    _a_local = 4
    print("Inside function, _a_global =", _a_global)
    print("Inside function, _a_local =", _a_local)

a_function()
print("After calling a_function, outside, _a_global now =", _a_global)
def a_function():
    _a_global = 10
    def _a_function2():
        global _a_global
        _a_global = 20
    print("Before calling _a_function2, _a_global =", _a_global)
    _a_function2()
    print("After calling _a_function2, _a_global =", _a_global)

a_function()
print("In main namespace, _a_global =", _a_global)

_a_global = 10
def a_function():
    def _a_function2():
        global _a_global
        _a_global = 20
    print("Before calling _a_function2, _a_global =", _a_global)
    _a_function2()
    print("After calling _a_function2, _a_global =", _a_global)

a_function()
print("In main namespace, _a_global =", _a_global)


**********

Output (first 500 chars):

**********
9
10
1
0
Updated x after reassignment: 10
Before calling a_function, outside the function, _a_global = 10
Before calling a_function, outside the function, _b_global = 15
Inside function, _a_global = 4
Inside function, _b_global = 9
Inside function, _a_local = 3
After calling a_function, outside, _a_global (still) = 10
After calling a_function, outside, _b_global (still) = 15
NameError: name '_a_local' is not defined
Inside function, _a_local = 4
Inside function, _a_global = 10
Outside function, 
**********
No errors.
======================================================================
Script: basic_io1.py

Contents:

**********
#############################
# FILE INPUT
#############################
# Open a file for reading
import os
import sys

if not os.path.exists('../sandbox/test.txt'): ## make sure the file exists
    print("not found: ../sandbox/test.txt")
    sys.exit(1)

f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

if not os.path.exists('../sandbox/test.txt'): ## make sure the file exists
    print("not found: ../sandbox/test.txt")
    sys.exit(1)

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()
**********

Output (first 500 chars):

**********
not found: ../sandbox/test.txt

**********
No errors.
======================================================================
Script: cfexercises1.py

Contents:

**********
import sys


def foo_1(x=1):
    return x ** 0.5

def foo_2(x=1, y=1):
    if x > y:
        return x
    return y

def foo_3(x=1, y=1, z=1):
    if x > y:
        x, y = y, x
    if x > z:
        x, z = z, x
    if y > z:
        y, z = z, y
    return [x, y, z]

def foo_4(x=1):
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

def foo_5(x=1): # a recursive function that calculates the factorial of x
    if x == 0 or x == 1:
        return 1
    elif x > 1:
        return x * foo_5(x - 1)
    else:
        return "Error negative numbers"

def foo_6(x=1): # Calculate the factorial of x without if statement
    if x < 0:
        return "Error negative numbers"
    else:
        facto = 1
        while x > 0:
            facto = facto * x
            x = x - 1
            return facto

def main(argv):

    if len(argv) == 4:
        try:
            x = int(argv[1])
            y = int(argv[2])
            z = int(argv[3])
        except ValueError:
            print("Error: x, y and z should be numbers")
            return 1

    else:
        print(" Now input your own values for x, y and z")
        try:
            x = input("Enter a number for x: ")
            if not x:  # check for empty input
                print("Error: No input provided for x")
                return 1
            if not x.isdigit():
                print("Error: x should be a number")
                return 1
            x = int(x)
            
            y = input("Enter a number for y: ")
            if not y:  # check for empty input
                print("Error: No input provided for y")
                return 1
            if not y.isdigit():
                print("Error: y should be a number")
                return 1
            y = int(y)
        
            z = input("Enter a number for z: ")
            if not z:   # check for empty input
                print("Error: No input provided for z")
                return 1
            if not z.isdigit():
                print("Error: z should be a number")
                return 1
            z = int(z)
        except EOFError:
            print("Error: Input was terminated unexpectedly")
            return 1
        except KeyboardInterrupt:
            print("\nProgram terminated by user")
            return 1

        print(foo_1(x))
        print(foo_2(x,y))
        print(foo_3(x,y,z))
        print(foo_4(x))
        print(foo_5(x))
        print(foo_6(x))
        return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

**********

Output (first 500 chars):

**********
 Now input your own values for x, y and z
Enter a number for x: Error: Input was terminated unexpectedly

**********
No errors.
======================================================================
Script: debugme.py

Contents:

**********
def buggyfunc(x):
    y = x
    for i in range(x):
        try:
            y = y-1
            z = x/y
        except:
            print(f"This didn't work;{x = }; {y = }")
    return z

buggyfunc(20)

def buggyfunc(x):
    y = x
    for i in range(x):
        try:
            y = y-1
            z = x/y
        except ZeroDivisionError:
            print(f"The result of dividing a number by zero is undefined")
        except:
            print(f"This didn't work;{x = }; {y = }")
        else:
            print(f"OK; {x = }; {y = }, {z = };")
    return z

buggyfunc(20)

**********

Output (first 500 chars):

**********
This didn't work;x = 20; y = 0
OK; x = 20; y = 19, z = 1.0526315789473684;
OK; x = 20; y = 18, z = 1.1111111111111112;
OK; x = 20; y = 17, z = 1.1764705882352942;
OK; x = 20; y = 16, z = 1.25;
OK; x = 20; y = 15, z = 1.3333333333333333;
OK; x = 20; y = 14, z = 1.4285714285714286;
OK; x = 20; y = 13, z = 1.5384615384615385;
OK; x = 20; y = 12, z = 1.6666666666666667;
OK; x = 20; y = 11, z = 1.8181818181818181;
OK; x = 20; y = 10, z = 2.0;
OK; x = 20; y = 9, z = 2.2222222222222223;
OK; x = 20; y =
**********
No errors.
======================================================================
Script: boilerplate.py

Contents:

**********
def main(argv):
    print('This is a boilerplate') # NOTE: indented using two tabs or four spaces


# !/usr/bin/env python3

"""Description of this program or application.
You can use several lines"""

__appname__ = '[application name here]'
__author__ = 'Your Name (your@email.address)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__":
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)


**********

Output (first 500 chars):

**********
This is a boilerplate

**********
No errors.
======================================================================
Script: basic_io2.py

Contents:

**********
#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
import os
import sys

if not os.path.exists('../sandbox/test.txt'): ## make sure the folder exists
    print("not found: ../sandbox/test.txt")
    sys.exit(1)
    
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()

**********

Output (first 500 chars):

**********
not found: ../sandbox/test.txt

**********
No errors.
======================================================================
Script: control_flow.py

Contents:

**********
# !/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""
# docstrings are considered part of the running code (normal comments are
# stripped). Hence, you can access your docstrings at run time.
__author__ = 'Samraat Pawar (s.pawar@imperial.ac.uk)'
__version__ = '0.0.1'

import sys

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return f"{x} is Even!"
    return f"{x} is Odd!"

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return f"No divisor found for {x}!" # Each function can return a value or a variable.
    return f"The largest divisor of {x} is {largest}"

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
            print(f"{x} is not a prime: {i} is a divisor")
            return False
    print(f"{x} is a prime!")
    return True

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print(f"There are {len(allprimes)} primes between 2 and {x}")
    return allprimes
      
def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

**********

Output (first 500 chars):

**********
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is
**********
No errors.
======================================================================
Script: align_seqs_fasta.py

Contents:

**********
import os
import csv


def read_fasta(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
    seq = ''
    for line in lines:
        if not line.startswith('>'):
            seq += line.strip()
    return seq


s1 = read_fasta('../data/407228412.fasta')
s2 = read_fasta('../data/407228326.fasta')
# Two example sequences to match
# seq2 = "ATCGCCGGATTACGGG"
# seq1 = "CAATTCGGAT"

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(s1)
l2 = len(s2)
if l1 >= l2:
    s1 = s1
    s2 = s2
else:
    s1 = s2
    s2 = s1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences

my_best_align = []
my_best_score = 0

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = [("." * i + s2)] # store the best alignment
        my_best_score = z
    elif z == my_best_score:
        my_best_align.append(("." * i + s2)) # if same score, append this alignment
print(my_best_align)
print(s1)
print("Best score:", my_best_score)

results_dir = '../results'
if not os.path.exists(results_dir):
    os.makedirs(results_dir)

results_file = os.path.join(results_dir, 'align_fasta.csv')

with open(results_file, 'w', newline='') as file:
    file = csv.writer(file)
    file.writerow([my_best_align])
    file.writerow(["Best score:" + str(my_best_score)])
**********

Output (first 500 chars):

**********
*-**---*--*---*-------*-*---*-*--*-*-*---*---*-----*--***----*--********-**---**--*---***------*-*--**---*-*---*-----*--****--------*--*--*-------**-*--*-*-----*-***-----**-----*-*-**--*--------*--**---*-**--*---*-**---*-*-*-*--**-*-******------**--*---*------****-*-*----*---*-------*-------------**-*-**--**-*------*-*--------**--*---------**---------*-**-------**-*--*--*--------*------------*-*-*--*-*---*-*-*--*-*----------**--------*-*--*------*-------**-----*--------*-----*--*--*----------*--
**********
No errors.
======================================================================
Script: lc1.py

Contents:

**********
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 
latin_names = [bird[0] for bird in birds]
print (str(latin_names))

common_names = [bird[1] for bird in birds]
print (str(common_names))

mean_body_masses = [bird[2] for bird in birds]
print (str(mean_body_masses))

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

latin_names = [] # create list for latin names
for bird in birds:
    latin_names.append(bird[0])
print (str(latin_names))

common_names = [] # create list for common names
for bird in birds:      
    common_names.append(bird[1])
print (str(common_names))   

mean_body_masses = [] # create list for mean body masses
for bird in birds:
    mean_body_masses.append(bird[2])
print (str(mean_body_masses))

# A nice example out out is:
# Step #1:
# Latin names:
# ['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
# ... etc.
 
**********

Output (first 500 chars):

**********
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********
No errors.
======================================================================
Script: sysargv.py

Contents:

**********
# !/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))

**********

Output (first 500 chars):

**********
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********
No errors.
======================================================================
Script: oaks_debugme.py

Contents:

**********
import csv
import sys
# import ipdb; ipdb.set_trace()
from fuzzywuzzy import fuzz


def check_required_package():  # Check for required package
    try:
        __import__('fuzzywuzzy')
    except ImportError:
        print("Error: The fuzzywuzzy package is missing. Please install it to proceed.")
        sys.exit(1)


#Define function
def is_an_oak(name):
    # """ Returns True if name is starts with 'quercus' 
    # >>> is_an_oak('Quercus robur')
    # True
    # >>> is_an_oak('Acer pseudoplatanus')
    # False
    # """
    return fuzz.partial_ratio(name.lower(), 'quercus') >= 80

def main(argv): 
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    
    header = next(taxa)  # get the header line.
    if header != ['Genus', 'Species']:
        taxa = csv.reader(f)
    else:
        next(taxa)  # skip the header line.
    
    # for row in taxa:
    #     print(row)   # check reading the file correctly.


    csvwrite = csv.writer(g)
    csvwrite.writerow(['Genus', 'Species'])
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ZhouYang_zy3425/week2/code/oaks_debugme.py", line 4, in <module>
    from fuzzywuzzy import fuzz
ModuleNotFoundError: No module named 'fuzzywuzzy'

**********
======================================================================
Script: tuple.py

Contents:

**********
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by
# species 
# 
# A nice example output is:
# 
# Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
# ... etc.

birds_tuple = ()
for birds in birds: 
    birds_tuple += (f'Latin name: {birds[0]} Common name: {birds[1]} Mass: {birds[2]}',) 

print('\n'.join(birds_tuple))
**********

Output (first 500 chars):

**********
Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
Latin name: Delichon urbica Common name: House martin Mass: 19
Latin name: Junco phaeonotus Common name: Yellow-eyed junco Mass: 19.5
Latin name: Junco hyemalis Common name: Dark-eyed junco Mass: 19.6
Latin name: Tachycineata bicolor Common name: Tree swallow Mass: 20.2

**********
No errors.
======================================================================
Script: test_control_flow.py

Contents:

**********
# !/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""
# docstrings are considered part of the running code (normal comments are
# stripped). Hence, you can access your docstrings at run time.
__author__ = 'Zhou Yang(zy3425@imperial.ac.uk)'
__version__ = '0.0.1'

import sys
import doctest

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x < 0:
        if -x % 2 == 0: 
            return f"{x} is Even!"
        else:
            return f"{x} is Odd!"
    if x % 2 == 0: #The conditional if
        return f"{x} is Even!"
    return f"{x} is Odd!"

      
def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(even_or_odd(10))
    print(even_or_odd(-5))
    print(even_or_odd(-2))

   
if (__name__ == "__main__"):
    status = main(sys.argv)
    doctest.testmod() 
**********

Output (first 500 chars):

**********
22 is Even!
33 is Odd!
10 is Even!
-5 is Odd!
-2 is Even!

**********
No errors.
======================================================================
Script: loops.py

Contents:

**********
# FOR loops
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loop
z = 0
while z < 100:
    z = z + 1
    print(z)

**********

Output (first 500 chars):

**********
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

**********
No errors.
======================================================================
Script: basic_csv.py

Contents:

**********
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
with open('../data/testcsv.csv','r') as f:

    csvread = csv.reader(f)
    temp = []
    for row in csvread:
        temp.append(tuple(row))
        print(row)
        print("The species is", row[0])

# write a file containing only species name and Body mass
with open('../data/testcsv.csv','r') as f:
    with open('../data/bodymass.csv','w') as g:

        csvread = csv.reader(f)
        csvwrite = csv.writer(g)
        for row in csvread:
            print(row)
            csvwrite.writerow([row[0], row[4]])
**********

Output (first 500 chars):

**********
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagas
**********
No errors.
======================================================================
Script: align_seqs.py

Contents:

**********
import os
import csv

with open('../data/DNA1.txt', 'r') as s1, open('../data/DNA2.txt', 'r') as s2:
    s1 = s1.read() 
    s2 = s2.read()
# Two example sequences to match
# seq2 = "ATCGCCGGATTACGGG"
# seq1 = "CAATTCGGAT"

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(s1)
l2 = len(s2)
if l1 >= l2:
    s1 = s1
    s2 = s2
else:
    s1 = s2
    s2 = s1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences

my_best_align = None
my_best_score = 0

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)

results_dir = '../results'
if not os.path.exists(results_dir):
    os.makedirs(results_dir)

results_file = os.path.join(results_dir, 'align.csv')

with open(results_file, 'w', newline='') as file:
    file = csv.writer(file)
    file.writerow([my_best_align])
    file.writerow([s1])
    file.writerow(["Best score:" + str(my_best_score)])
**********

Output (first 500 chars):

**********
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCG
**********
No errors.
======================================================================
Script: read_csv.R

Contents:

**********
setwd("../code/")
MyData <- read.csv("../data/trees.csv")
ls(pattern = "My*") # Check that MyData has appeared
class(MyData)
head(MyData)
str(MyData) 
MyData <- read.table("../data/trees.csv", sep = ',', header = TRUE) #another way
MyData <- read.csv("../data/trees.csv", skip = 5) # skip first 5 linesdata

**********

Output (first 500 chars):

**********
[1] "MyData"
[1] "data.frame"
             Species Distance.m Angle.degrees
1    Populus tremula   31.66583      41.28264
2      Quercus robur   45.98499      44.53592
3      Ginkgo biloba   31.24177      25.14626
4 Fraxinus excelsior   34.61667      23.33613
5     Betula pendula   45.46617      38.34913
6     Betula pendula   48.79550      33.59231
'data.frame':	120 obs. of  3 variables:
 $ Species      : chr  "Populus tremula" "Quercus robur" "Ginkgo biloba" "Fraxinus excelsior" ...
 $ Distanc
**********
No errors.
======================================================================
Script: Vectorize2.R

Contents:

**********
# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list = ls())

stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100){

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0

  for (pop in 1:length(p0)) { #loop through the populations

    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
    
     }
  
  }
 return(N)

}

# Now write another function called stochrickvect that vectorizes the above to
# the extent possible, with improved performance: 

stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2, numyears = 100) {
  N <- matrix(NA, numyears, length(p0))
  N[1, ] <- p0
    
  # create all the random noise
  randomNoise <- matrix(rnorm(n = (numyears-1) * length(p0), mean = 0, sd = sigma), nrow = numyears-1, ncol = length(p0))
  
  # calculate
  for (yr in 2:numyears) {
    N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr-1, ] / K) + randomNoise[yr-1, ])
  }
  return(N)
}
# Show performance difference
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))

print("Original Stochastic Ricker takes:")
print(system.time(res1<-stochrick()))
**********

Output (first 500 chars):

**********
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.014   0.003   0.018 
[1] "Original Stochastic Ricker takes:"
   user  system elapsed 
  0.118   0.012   0.130 

**********
No errors.
======================================================================
Script: break.R

Contents:

**********
i <- 0 #Initialize i
    while (i < Inf) {
        if (i == 10) {
            break 
        } else { # Break out of the while loop!  
            cat("i equals " , i , " \n")
            i <- i + 1 # Update i
    }
}
**********

Output (first 500 chars):

**********
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  

**********
No errors.
======================================================================
Script: sample.R

Contents:

**********
######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean # nolint: line_length_linter.
myexperiment <- function(popn,n) { # nolint
    pop_sample <- sample(popn, n, replace = FALSE) # nolint: indentation_linter. # nolint: indentation_linter, line_length_linter.
    return(mean(pop_sample)) # nolint: return_linter.
}

## Calculate means using a FOR loop on a vector without preallocation:
loopy_sample1 <- function(popn, n, num) {
    result1 <- vector() #Initialize empty vector of size 1
    for(i in 1:num) {
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
    result2 <- vector(,num) #Preallocate expected size
    for(i in 1:num) {
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
    result3 <- vector("list", num) #Preallocate expected size
    for(i in 1:num) {
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: Vectorize1.R

Contents:

**********
M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M) {
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]) {
    for (j in 1:Dimensions[2]) {
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********

Output (first 500 chars):

**********
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.034   0.000   0.033 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.001   0.000   0.000 

**********
No errors.
======================================================================
Script: PP_Regress.R

Contents:

**********
# PP_Regress.R
# Performs linear regressions for each Feeding Type × Life Stage combination
# and outputs both a PDF plot and a CSV table with regression statistics.

# Load required libraries
library(ggplot2)
library(dplyr)

# Import dataset (relative path: script in /code, data in ../data)
data <- read.csv("../data/EcolArchives-E089-51-D1.csv")

# Remove missing values in relevant columns
data <- data %>%
  filter(!is.na(Prey.mass),
         !is.na(Predator.mass),
         !is.na(Type.of.feeding.interaction),
         !is.na(Predator.lifestage))

# Initialize dataframe for regression results
results <- data.frame(
  FeedingType = character(),
  LifeStage = character(),
  Slope = numeric(),
  Intercept = numeric(),
  R_squared = numeric(),
  F_statistic = numeric(),
  P_value = numeric(),
  stringsAsFactors = FALSE
)

# Open PDF device for plot output
pdf("../results/PP_Regress.pdf", width = 10, height = 8)

# Create the figure
p <- ggplot(data, aes(x = log(Prey.mass), y = log(Predator.mass),
                      color = Type.of.feeding.interaction)) +
  geom_point(alpha = 0.6) +
  facet_wrap(~Predator.lifestage) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    x = "Log Prey Mass",
    y = "Log Predator Mass",
    color = "Feeding Type"
  ) +
  theme_bw() +
  theme(legend.position = "right")

# Write the plot to PDF
print(p)

# Close PDF
dev.off()

# Perform regressions for each combination of Feeding Type × Life Stage
for (stage in unique(data$Predator.lifestage)) {
  for (type in unique(data$Type.of.feeding.interaction)) {
    subset_data <- data %>%
      filter(Predator.lifestage == stage,
             Type.of.feeding.interaction == type)
    
    # Skip if insufficient data
    if (nrow(subset_data) > 2) {
      model <- lm(log(Predator.mass) ~ log(Prey.mass), data = subset_data)
      summary_stats <- summary(model)
      
      # Extract F-statistic and p-value safely
      if (!is.null(summary_stats$fstatistic)) {
        F_val <- summary_stats$fstatistic[1]
        P_val <- pf(F_val,
                    summary_stats$fstatistic[2],
                    summary_stats$fstatistic[3],
                    lower.tail = FALSE)
      } else {
        F_val <- NA
        P_val <- NA
      }
      
      # Append results
      results <- rbind(results, data.frame(
        FeedingType = type,
        LifeStage = stage,
        Slope = coef(model)[2],
        Intercept = coef(model)[1],
        R_squared = summary_stats$r.squared,
        F_statistic = F_val,
        P_value = P_val,
        stringsAsFactors = FALSE
      ))
    }
  }
}

# Save regression summary to CSV
write.csv(results, "../results/PP_Regress_Results.csv", row.names = FALSE)

# Print completion message
cat("Linear regressions complete!\n")
cat("Saved outputs:\n")
cat(" - ../results/PP_Regress.pdf\n")
cat(" - ../results/PP_Regress_Results.csv\n")

**********

Output (first 500 chars):

**********

**********
Errors:
**********

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/EcolArchives-E089-51-D1.csv': No such file or directory
Execution halted

**********
======================================================================
Script: R_conditionals.R

Contents:

**********
# Checks if an integer is even
is.even <- function(n = 2) {
  if (n %% 2 == 0) {
    return(paste(n,'is even!'))
  } else {
  return(paste(n,'is odd!'))
  }
}

is.even(6)


# Checks if a number is a power of 2
is.power2 <- function(n = 2) {
  if (log2(n) %% 1==0) {
    return(paste(n, 'is a power of 2!'))
  } else {
  return(paste(n,'is not a power of 2!'))
    }
}

is.power2(4)


# Checks if a number is prime
is.prime <- function(n) {
  if (n==0) {
    return(paste(n,'is a zero!'))
  } else if (n==1) {
    return(paste(n,'is just a unit!'))
  }

  ints <- 2:(n-1)

  if (all(n%%ints!=0)) {
    return(paste(n,'is a prime!'))
  } else {
  return(paste(n,'is a composite!'))
    }
}

is.prime(3)
**********

Output (first 500 chars):

**********
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********
No errors.
======================================================================
Script: apply1.R

Contents:

**********
## Build a random matrix

M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
**********

Output (first 500 chars):

**********
 [1] -0.52290753  0.27684525  0.40766392 -0.42838276  0.23850391  0.05295224
 [7]  0.42464346 -0.51555641  0.03127224  0.18199406
 [1] 0.8185669 0.4042344 0.7158315 1.6569023 1.2789852 0.7293111 0.9156757
 [8] 0.8889519 0.6215453 1.5565237
 [1] -0.06782394 -0.08408301 -0.06771192  0.26876613  0.08466067  0.06835242
 [7]  0.10335710 -0.04245643 -0.22421208  0.10817944

**********
No errors.
======================================================================
Script: basic_io.R

Contents:

**********
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("week3/data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "week3/results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "week3/results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "week3/results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "week3/results/MyData.csv", col.names=FALSE) # ignore column names


**********

Output (first 500 chars):

**********

**********
Errors:
**********
Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file 'week3/data/trees.csv': No such file or directory
Execution halted

**********
======================================================================
Script: Florida.R

Contents:

**********
script_path <- dirname(sys.frame(1)$ofile)
setwd(script_path)

rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

set.seed(0)

observed_cor <- cor(ats$Year, ats$Temp) # calculate correlation

repeatTimes <- 10000
random_cors <- numeric(repeatTimes)
for(i in 1:repeatTimes) {
     shuffled_temps <- sample(ats$Temp) # shuffle temperatures
    random_cors[i] <- cor(ats$Year, shuffled_temps) # calculate correlation with shuffled temps
}
# Now random_cors contains 10000 correlation coefficients from the permutations

p_value <- sum(abs(random_cors) >= abs(observed_cor)) / repeatTimes

pdf("../results/Florida_analysis1.pdf", width = 8, height = 6)
plot(ats$Year, ats$Temp, 
     main = sprintf("Temperature Trends in Key West (correlation = %.3f)", observed_cor),
     xlab = "Year", 
     ylab = "Temperature (°C)",
     pch = 16,
     col = "darkblue")
abline(lm(Temp ~ Year, data = ats), col = "red", lwd = 2)
dev.off()

pdf("../results/Florida_analysis2.pdf", width = 8, height = 6)
hist(random_cors,
     main = "Distribution of Random Correlations",
     xlab = "Correlation Coefficient")
abline(v = observed_cor, col = "red", lwd = 2)
dev.off()

pdf("../results/Florida_analysis3.pdf", width = 8, height = 6)
baseline_temp <- mean(ats$Temp[1:5]) 
temp_changes <- ats$Temp - baseline_temp

plot(ats$Year, temp_changes,
     type = "b",
     main = sprintf("Temperature Changes Relative to 1901-1905 Average (%.2f°C)", 
                   baseline_temp),
     xlab = "Year",
     ylab = "Temperature Change (°C)",
     col = "blue",
     pch = 16)
lines(lowess(ats$Year, temp_changes), col = "red", lwd = 2)
legend("topleft", 
       legend = c("Annual change", "Smoothed trend"),
       col = c("blue", "red", "red"),
       lty = c(1, 1, 2),
       pch = c(16, NA, NA),
       bty = "n")

dev.off()

#Save results to CSV files
results_df <- data.frame(Observed_Correlation = observed_cor, P_Value = p_value)
write.csv(results_df, "../results/Florida.csv", row.names = FALSE)

# Print results
cat("\nresults：\n")
cat("correlation：", round(observed_cor, 4), "\n")
cat("p value：", round(p_value, 4), "\n")
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Error in sys.frame(1) : not that many frames on the stack
Calls: dirname -> sys.frame
Execution halted

**********
======================================================================
Script: boilerplate.R

Contents:

**********
# A boilerplate R script

MyFunction <- function(Arg1, Arg2) {
  
  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
    
  return (c(Arg1, Arg2)) #this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
**********

Output (first 500 chars):

**********
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********
No errors.
======================================================================
Script: apply2.R

Contents:

**********
SomeOperation <- function(v) { # (What does this function do?)
  if (sum(v) > 0) { #note that sum(v) is a single (scalar) value
    return (v * 100)
  } else {
  return (v)
    }
}

M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
**********

Output (first 500 chars):

**********
             [,1]       [,2]      [,3]       [,4]        [,5]       [,6]
 [1,]  0.07159361   48.90343 127.24979  -84.67494  158.878755  0.3461337
 [2,] -0.13612569   37.99848 113.37904   99.80776  -16.451728 -0.6222332
 [3,] -0.33586964   10.21645  86.23010  -29.24674   33.849020 -1.7207151
 [4,]  0.46834952  131.02274 128.07452  -33.89893   18.229361 -1.3017017
 [5,] -1.27553170   76.71429 140.16331  -97.71186  -51.589701  1.1520511
 [6,] -2.66635628 -158.39903  67.57954  109.35116   -4.935445 
**********
No errors.
======================================================================
Script: try.R

Contents:

**********
doit <- function(x) {
    temp_x <- sample(x, replace = TRUE)
    if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
         print(paste("Mean of this sample was:", as.character(mean(temp_x))))
        }
    else {
        stop("Couldn't calculate mean: too few unique values!")
        }
    }

set.seed(1345) # again, to get the same result for illustration

popn <- rnorm(50)

hist(popn)

lapply(1:15, function(i) doit(popn))
result <- lapply(1:15, function(i) try(doit(popn), FALSE))
class(result)

result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
    result[[i]] <- try(doit(popn), FALSE)
    }
**********

Output (first 500 chars):

**********
[1] "Mean of this sample was: -0.11620822588674"
[1] "Mean of this sample was: -0.0468516755995931"
[1] "Mean of this sample was: -0.0890228211466614"
[1] "Mean of this sample was: -0.124229742255296"

**********
Errors:
**********
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Calls: lapply -> FUN -> doit
Execution halted

**********
======================================================================
Script: control_flow.R

Contents:

**********
a <- TRUE
if (a == TRUE) {
    print ("a is TRUE")
} else {
    print ("a is FALSE")
}

z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}

for (i in 1:10) {
    j <- i * i
    print(paste(i, " squared is", j ))
}

for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')) {
      print(paste('The species is', species))
}

v1 <- c("a","bc","def")
for (i in v1) {
    print(i)
}

i <- 0
while (i < 10) {
    i <- i+1
    print(i^2)
}
**********

Output (first 500 chars):

**********
[1] "a is TRUE"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********
No errors.
======================================================================
Script: Ricker.R

Contents:

**********
Ricker <- function(N0=1, r=1, K=10, generations=50)
{
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations

  N <- rep(NA, generations)    # Creates a vector of NA

  N[1] <- N0
  for (t in 2:generations)
  {
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations=10), type="l")
**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: TreeHeight.R

Contents:

**********
# This function calculates heights of trees given distance of each tree
# from its base and angle to its top, using  the trigonometric formula
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"
script_path <- dirname(sys.frame(1)$ofile)
setwd(script_path)

treeData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

TreeHeight <- function(degrees, distance) {
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    print(paste("Tree height is:", height))
  
    return (height)
}

treeData$Tree.Height.m <- TreeHeight(treeData$Angle.degrees, treeData$Distance.m)
write.csv(treeData, "../results/TreeHts.csv", row.names = FALSE)
**********

Output (first 500 chars):

**********

**********
Errors:
**********
Error in sys.frame(1) : not that many frames on the stack
Calls: dirname -> sys.frame
Execution halted

**********
======================================================================
Script: next.R

Contents:

**********
for (i in 1:10) {
  if ((i %% 2) == 0) # check if the number is odd
    next # pass to next iteration of loop 
  print(i)
}
**********

Output (first 500 chars):

**********
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********
No errors.
======================================================================
Script: browse.R

Contents:

**********
Exponential <- function(N0 = 1, r = 1, generations = 10) {
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations) {
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")

**********

Output (first 500 chars):

**********
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********
No errors.
======================================================================
Script: preallocate.R

Contents:

**********
NoPreallocFun <- function(x) {
    a <- vector() # empty vector
    for (i in 1:x) {
        a <- c(a, i) # concatenate
        print(a)
        print(object.size(a))
    }
}

system.time(NoPreallocFun(10))

PreallocFun <- function(x) {
    a <- rep(NA, x) # pre-allocated vector
    for (i in 1:x) {
        a[i] <- i # assign
        print(a)
        print(object.size(a))
    }
}

system.time(PreallocFun(10))
**********

Output (first 500 chars):

**********
[1] 1
56 bytes
[1] 1 2
56 bytes
[1] 1 2 3
64 bytes
[1] 1 2 3 4
64 bytes
[1] 1 2 3 4 5
80 bytes
[1] 1 2 3 4 5 6
80 bytes
[1] 1 2 3 4 5 6 7
80 bytes
[1] 1 2 3 4 5 6 7 8
80 bytes
[1] 1 2 3 4 5 6 7 8 9
96 bytes
 [1]  1  2  3  4  5  6  7  8  9 10
96 bytes
   user  system elapsed 
  0.009   0.001   0.011 
 [1]  1 NA NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2 NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3 NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4 NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4  5 NA 
**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 63
Scripts successful: 48
Scripts with errors: 15
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

